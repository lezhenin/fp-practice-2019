module Task3_3 where

{-
  Задание 3.3
  Множество на основе предикатов
-}

import Data.Semigroup

data PSet a = PSet{ contains :: (a -> Bool) }
-- Реализуйте классы Monoid и Functor
-- Объясните в комментариях, почему они реализованы именно так

-- Класс Semigroup описывает типы, на которых определен
-- бинарный ассоциативный оператор.
instance Semigroup (PSet a) where
    -- Для множества на основе предикатов, может быть
    -- использована ассоциативная операция логическо сложения
    -- OR, что соответствует объединению множеств.
    (<>) (PSet px) (PSet py) = PSet (\e -> (px e) || (py e))

-- Класс Monoid описывает типы, на которых определен
-- бинарный ассоциативный оператор с нейтральным элементом.
instance Monoid (PSet a)  where
    -- Для операции логического сложения OR, нейтральным
    -- элементом является False
    mempty  = PSet (\_ -> False)
    -- Ассоциативный оператор наследуется от Semigroup
    mappend = (<>)

-- Класс Functor описывает параметризованные типы,
-- данные внутри которых могут быть преобразованы.
-- Чтобы отобразить элементы из однгого множетсва PSet
-- a в другое множество PSet b, необходима функция
-- преобразования f :: (b -> a). В таком случае fmap
-- будет иметь следующий вид:
--     fmap :: (b -> a) -> PSet a -> PSet b
--     fmap f PSet(pa) = PSet (\x -> pa $ f b)
-- Однако, это противоречит определению fmap для
-- класса Functor:
--     fmap :: (a -> b) -> f a -> f b
-- Поэтому реализовать Functor PSet невозможно.
-- Для этого требуется обратная функция.